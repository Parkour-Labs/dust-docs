{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>dust</code>","text":"<p>Join our Telegram Group</p> <p><code>dust</code> is a local-first, synchronizable (coming soon) database and state management solution built for Flutter developers. It is developed while we are building a cross-platform handwriting note-taking app called dynote. dynote has not been open-sourced yet, but we aim to release its source code under GPLv3 when have some spare time. <code>dust</code> is built specifically to solve the frustrations that we faced when we were building dynote.</p> <p>Supported Platforms: iOS, Android, MacOS, Linux, Windows</p> <p>WARNING: what's shown in this documentation right now is not the API that dust is going to have. We are currently working on migrating <code>dust</code> to adopt a freezed-style API. Details of this work can be seen here. We expect this to be done by Feb 25, 2024.</p>"},{"location":"#fearless-local-first","title":"Fearless Local First","text":"<p>(This slogan sounds like a Rust copycat, huh?)</p> <p>When we were picking a database for dust, we could not find one that fitted our needs for building a productivity software. We want to provide local-first software targeting all the native flutter platforms as well as providing sync capabilities. This is not possible with other database solutions. We could not simply choose a local-first database without worrying about synchronization later on.</p>"},{"location":"#error-free-state-management","title":"Error-free State Management","text":"<p>While we were building the app dynote, we had a lot of issues with State Management. They were always too \"smart\" for us, and often times we will have to work around their \"smart\" designs to trigger a rebuild. Further, we also need to make sure that the application state is in sync with the database state, which is very hard to do and and very prune to errors. We want to solve this issue as well. It also often is the case that we forget to subscribe to changes of a state -- wasting us precious time on debugging state related issues.</p>"},{"location":"blog/","title":"ParkourLabs Blog","text":"<p>Welcome to the blog of ParkourLabs.</p> <p>ParkourLabs is currently formed by a group of college friends trying to have fun by building stuff together.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/","title":"Introducing dust v0.0.1","text":"<ul> <li>Github Link</li> <li>Read on Medium</li> </ul> <p>This is going to get us embarrassed real bad. Please don\u2019t laugh at us if you think we are stupid.</p> <p>I wasn\u2019t really going to release this out loud to the public, but I realized that we are at a stage where we need some feedback and a little nudge from the community. Having this project worked on and used \u201cinternally\u201d on an yet-to-launch note-taking app will not get it anywhere.</p> <p>Be warned that dust is far far from mature yet. The API is different from what we show here (we are doing a major API refactoring which would take us about a week\u2019s time). Many critical features are missing. No sensible docs. You probably would have difficulty getting it building for your app because we tried to run Rust with Flutter. We haven't even published on pub.dev. Oh, by the way, the package name is still qinhuai, which is what we used to call it and we haven\u2019t updated that yet.</p> <p>However, if you aren't afraid of getting your hands dirty with git submodules and cargo or shooting yourself in the foot by using a constantly-having-massive-breaking-changes database/state management solution, you are welcome to try it out in your new pet Flutter project!</p> <p>Regardless, here is our telegram link. Do hop in and give us some feedback and encouragement :-)</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#what-is-the-problem","title":"What is the problem?","text":"<p>As a front-end developer, there are three major things that we need to worry about and cause the most amount of trouble for us: state management, persistence, and synchronization. dust is our attempt to settle all these three questions at once.</p> <p>The problem that we see with existing solutions is that they often require you to manage so many different things. As a front-end developer, you often need to ensure that</p> <ol> <li> <p>The UI state and the application state are in sync;</p> </li> <li> <p>The application state and the local database state are in sync;</p> </li> <li> <p>The local database state and the remote state are in sync (if you choose     to support cross-platform sync).</p> </li> </ol> <p>If any of these things are not correctly managed, you will have a buggy application. And if there is anything that I know about synchronization, it would be that it is hard. Super hard. How hard?</p> <p>Spotify desktop\u2019s \u201cFriends Activity\u201d barely worked on my friend\u2019s machine:</p> <p></p> <p>Google\u2019s YouTube on iOS had a lot of UI glitches for me when I tried to switch from dark mode to light mode. (Can\u2019t find a screenshot right now).</p> <p>And these are not just some random small development teams doing these apps. They are huge companies with a large team dedicated to the development. Yet, there are still problems in managing the front-end state somehow.</p> <p>Further, as a front-end developer, I often find myself engaged in this mental model of a View, a ViewModel, and Models, which would often lead me into this loophole of duplicating the same or similar code in several different places. Are these things really necessary? Can't a Model itself just somehow be a ViewModel?</p> <p>\u201cThis is impossible. You must be absurd.\u201d</p> <p>Yes, I agree. Things that exist do exist for a reason.</p> <p>However, not every app is like YouTube or Spotify or whatever that needs to handle sophisticated use cases and massive amounts of data. People share about technology that they are proud of, and more often than not, these technical solutions tend to be very nerdy and hard ones.</p> <p>More often than not, we can\u2019t afford to do like what they did. And in most situations, we DON\u2019T NEED to do what they do. You don\u2019t need to have AWS Cognito User Pool linked with DynamoDB and lots of custom resolvers with API Gateway and GraphQL to build a to-do list app or a small app for your business. You also don\u2019t need to implement clean architecture in any way or shape or form.</p> <p>What you need is to think about the specific problems and use cases that matter, and try to address the business logic directly with minimum friction from what your solution is. That\u2019s what we built dust for.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#what-leads-us-here","title":"What leads us here","text":"<p>Skip to here if you are not interested in how we arrived at dust.</p> <p>In roughly around Jan. 2021, my first year of college, I discovered Flutter. In my last year of high school, I worked at MarginNote for 6 months and had a decent amount of experience in the productivity software region. At that time, it was still a big problem where the majority of nice-to-use productivity software was on the iOS side. As a result, we started building an app called dynote.</p> <p>As we started building, quickly two problems emerged: state management solutions being sub-optimal and lack of a database solution that checked all the boxes for us.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#state-management","title":"State Management","text":"<p>We swapped out several different state management solutions, from BLoC to MobX to Riverpod, but none worked for us.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#are-immutable-data-better","title":"Are Immutable Data Better?","text":"<p>The first issue that we had with those very advanced state management solutions is that they often rely on data immutability. This is because, with immutable data, you can have a quick comparison between two objects, hence allowing the library to be notified of when a change occurred.</p> <pre><code>// In order for any state management solutions to work\npoints.value = [...points.value, newPoint];\n</code></pre> <p>However, this does not look ideal to us, as we were dealing with lots of stroke points per stroke that get updated quite frequently. This would be equivalent to having an \\(O(n^2)\\) operation every time we need to add something to the stroke.</p> <p>Granted, the UI still needs to be redrawn every time we make an update to the list, but having to copy the object again every time that we make an update does not feel nice. And, there is a difference in the real world too.</p> <p>I did a simple dirty test of rendering 10000 dots on a canvas with the two different variants of notifiers, one that which a copy of a list is made each time we update something and another where we just simply add to the list.</p> <pre><code>final class ListNotifier&lt;T&gt; extends ChangeNotifier\n    implements ListNotifierBase&lt;T&gt; {\n  ListNotifier(this.value);\n\n  @override\n  final List&lt;T&gt; value;\n\n  @pragma('vm:prefer-inline')\n  @override\n  void add(T item) {\n    // using a mutable list and then crow.\n    value.add(item);\n    notifyListeners();\n  }\n}\n\nfinal class ListCopyNotifier&lt;T&gt; extends ValueNotifier&lt;List&lt;T&gt;&gt;\n    implements ListNotifierBase&lt;T&gt; {\n  ListCopyNotifier(super.value);\n\n  @pragma('vm:prefer-inline')\n  @override\n  void add(T item) {\n    // similar to the normal copy action that you would perform.\n    value = [...value, item];\n  }\n}\n</code></pre> <p>I don\u2019t know how to measure the performance, but as can be shown here, there is a huge performance difference when I try to consecutively add 10000 points to the UI.</p> <p></p> <p>The tab on the left is using the <code>ListNotifier</code> and the one on the right is using the <code>ListCopyNotifier</code>.</p> <p>Compared with just manually calling notify every time, a significant portion of the CPU is wasted on doing the ListCopyNotifier.add method.</p> <p>An initial idea would be inside the freezed data class, we set the <code>makeCollectionsUnmodifiable</code> flag to false. This allows us to modify the collection inside a data class.</p> <pre><code>@Freezed(makeCollectionsUnmodifiable: false)\nclass Stroke with _$Stroke {\n  const Stroke._();\n  const factory Stroke({@Default([]) List&lt;Offset&gt; points}) = _Strole;\n\n  Stroke withAddPoint(Offset point) {\n    points.add(point);\n    return this;\n  }\n}\n</code></pre> <p>However, this alone won\u2019t work with most of the state management solutions. Because you are simply returning this, the comparison would end here, and it would not trigger an update in most of the state managers. We will have to work around the \"smart\" rendering-saving techniques of those state managers to force an update:</p> <pre><code>@Freezed(makeCollectionsUnmodifiable: false)\nclass Stroke with _$Stroke {\n  const Stroke._();\n  const factory Stroke({\n    @Default([]) List&lt;Offset&gt; points,\n    @Default(0) int forceUpdate,\n  }) = _Strole;\n\n  Stroke withAddPoint(Offset point) {\n    points.add(point);\n    return copyWith(forceUpdate: forceUpdate += 1);\n  }\n}\n</code></pre> <p>This would ensure that the equality checks between two states fail, therefore allowing the UI to be re-rendered. Having to dig through the source code of the state management library and try to bypass its limitations was not pleasant.</p> <p>This leads us to ask the question: at the end of the day, is it true that immutable data are better than mutable ones?</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#duplication-of-states","title":"Duplication of States","text":"<p>Another thing that you may have noticed, is that to cater to the needs for different state management solutions, we have to often create two sets of models representing the same data. One set is used to be persisted to the local disk, and the other set is to be used to update the user interface.</p> <p>For example, I could have a stroke that\u2019s a list of points declared in Isar:</p> <pre><code>@Collection\nclass Stroke {\n  // ..\n  List&lt;Point&gt; points;\n}\n</code></pre> <p>There is no way for me to directly modify the points of this model while still keeping the UI updated, as the List does not offer any reactivity. Often, you will need to create temporary variables that hold the <code>List&lt;Point&gt;</code>, compound with reactivity, and then by the time you finish modifying a stroke, you add it to the points stored in Isar. <p>And this is not just unique with strokes and points. Say that you are designing a file system, where a Folder can be either a parent or one of the children. It would be non-trivially hard to get everything right with the database state and a state management solution. For example, if you try to load the children and store them in your \"ViewModel\" of folders, what happens if I move one of the children out? How does the underlying state work? How do I notify other view models that such a change has occurred? Further, how do I keep the UI state consistent with the data state?</p> <p>Please don\u2019t laugh at me: the naive me back then spent a lot of time implementing the file management page for the note-taking app three times, each time trying to fix some issue that randomly bumped up that I did not previously think of. I thought it was a skill issue of mine that I could not get everything right. Granted, there are certain elements of that. However, now I also think that the current mental model of \u201cMVVM\u201d also contributed to a lot of the complexity concerning such an issue. You need to try to make different systems (the backend database, the state management solutions, and the UI) talk to each other, and they may not have the most compatible API ever.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#database","title":"Database","text":"<p>We not only had problems with state management, but we also had tons of issues with persistence and synchronization. Coming from an iOS background, I thought that allowing users to synchronize data across different platforms was a very simple task. Boy was I so wrong.</p> iOS Android MacOS Windows Linux Web Offline Sync Firebase \u2705 \u2705 \u2705 \u274c \u274c \u2705 \ud83d\udfe0 \u2705 Amplify \u2705 \u2705 \u274c \u274c \u274c \u274c \u2705 \u2705 Isar \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u274c ObjectBox \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u2705 Supabase \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 Appwrite \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 <p>\ud83d\udfe0 Indicates that there is partial support.</p> <p>However, supporting all of these platforms/features was one of our key requirements when we were developing the app Dynote. Further, when we started, Supabase and Appwrite were not as big as they are now.</p> <p>Ant if you dive deeper into the database platform support, you will realize that some of them are bad.</p> <p>For example: I\u2019ve hardly ever seen a so-called \u201cproduction-grade\u201d software written worse than AWS Amplify. Its DataStore does not work most of the time for me, for some obscure messages that no one could understand. It promises local support, but only when you dive in you realize that the local-first approach only works on mobile but on desktop. It allows you to write interfaces in the GraphQL schema, but it never generates the interface in Flutter code. There is no way of knowing how it loaded its links, and it\u2019s far from possible to keep the objects in sync across different places. Since I am currently interning at a small business building software for them and dealing with Amplify on a day-to-day basis, I could not even count how many times I shot myself in the foot by using Amplify.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#as-a-result","title":"As a result","text":"<p>We built dust.</p> <p>It was mostly Bridgecat\u2019s brain-child that dust is built. When I first encountered issues with state management, I thought it was my skill issue because although I started programming when I was 13 years old, I had always been a casual programmer. It took me a long time back then to figure out that if statements cannot directly live inside the body of a class.</p> <p>Bridgecat, however, is a genius. He built a Minecraft clone when he was in 5th grade using basic and OpenGL, and later on, rewrote it in C++ and OpenGL. He also did competitive programming. However, when he mentioned to me this idea, I was very skeptical. We were already slow in building the note-taking app because we did not have enough time, and we needed to build a new database and state-management solution, what? When is that going to be production-ready? When are we going to ship the app?</p> <p>However, we are just friends building apps together. We called our \u201ccompany\u201d ParkourLabs and one of the core missions that we had was \u201cfriends having fun together.\u201d I voiced my rejection, and bridgecat ignored it and went to work. I am glad he did.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#introducing-dust","title":"Introducing dust","text":"<p>*WARNING: The code shown below only indicate how dust's API will look like after we finish our current major refactoring (into using a freezed-like declaration style). We expect it to be done within a week by Feb 25, 2024. I want to publish dust by my birthday, so \u2026*</p> <p>Dust is our attempt to solve the problems that we have encountered while building the dynote app. Suppose that we are building a Todo list app (not again~)</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#define-a-model","title":"Define a Model","text":"<p>dust's API is heavily inspired by freezed, the package that we as Flutter developers love dearly for handling data classes and unions. For demo purposes, let's assume that we are building a todo-list app. (Hey, who doesn't like to-do lists?)</p> <pre><code>import 'package:dust/dust.dart';\n\npart 'todo.dust.dart';\n\n@Model()\nclass Todo with _$Todo {\n  Todo._();\n\n  factory Todo({\n    required String name,\n    String? description,\n    @DustDft(false) bool isCompleted,\n  }) = _Todo;\n}\n</code></pre> <p>Then, run code generation with build_runner, and your model has been set!</p> <pre><code>dart run build_runner build --delete-conflicting-outputs\n</code></pre>"},{"location":"blog/2024/02/19/introducing-dust-v001/#register-the-repository","title":"Register the repository","text":"<p>The code shown above will generate an additional class named $TodoRepository. The $ prefix is used to signify that it is generated code. For dust to work, you will need to register the $TodoRepository with dust.</p> <pre><code>Future&lt;void&gt; main() async {\n  final docsDir = await getApplicationDocumentsDirectory();\n  final dataPath = p.join(docsDir.path, 'data.dust');\n  Store.open(docsDir, [\n    const $TodoRepository(),\n  ]);\n  // ... other code\n}\n</code></pre> <p>Now you are all set!</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#crud-operations","title":"CRUD Operations","text":"<p>If you want to create a Todo, simply do as follows:</p> <pre><code>final todo = Todo(name: 'Write dust docs');\n</code></pre> <p>If you want to read a Todo, do as follows:</p> <pre><code>final todo = const $TodoRepository().get(todo.id);\n</code></pre> <p>If you want to update a Todo, simply do as follows:</p> <pre><code>todo.description$.set('It is so hard to document code.');\n</code></pre> <p>If you want to delete a Todo:</p> <pre><code>todo.delete();\n</code></pre> <p>If you want to query all the todos:</p> <pre><code>final todos = const $TodoRepository().all();\n</code></pre> <p>Look at the API above, and you will notice a few interesting things:</p> <ul> <li> <p>You don\u2019t have to worry about anything related to saving the data to the   database. Dust handles them for you. You just need to focus on creating the   model, using it, and deleting it when you need to.</p> </li> <li> <p>There is no async/await. Would it cause user-perceived lag? We think not.   Native software generally does not deal with huge amounts of data, and modern   databases are generally able to answer these queries at a very fast pace.</p> </li> <li> <p>We have yet to get to the network layer implementation yet, but the data will   even be automatically synchronized once we get our hands on it!</p> </li> </ul>"},{"location":"blog/2024/02/19/introducing-dust-v001/#links","title":"Links","text":"<p>One of the more advanced features in dust is the support of <code>Link</code>, <code>Multilinks</code>, and <code>Backlinks</code> in both persistence and state management. Say that now you want to add a tag:</p> <pre><code>@Model()\nclass Todo with _$Todo {\n  Todo._();\n\n  factory Todo({\n    required String name,\n    String? description,\n    @DustDft(false) bool isCompleted,\n    @Multilinks() List&lt;Tag&gt; tags,\n  }) = _Todo;\n}\n\n@Model()\nclass Tag with _$Tag {\n  Tag._();\n\n  factory Tag({\n    required String name,\n    @ColorSerializer() @Default(Colors.orange) color,\n    @Link Tag? parent,\n    @Backlinks(to: \"parent\") List&lt;Tag&gt; children,\n    @Backlinks(to: \"tags\") List&lt;Todo&gt; tags,\n  }) = _Todo;\n}\n</code></pre> <p>Then, dust would generate the corresponding fields for you with the relationships maintained. If you create a Tag and set its parent to some other Tag, then this Tag would appear in the children of the other Tag as well. More importantly, both tags would be of the exact same instance. This means that any transient fields that you store in the model can be used as a shared runtime state.</p> <pre><code>final parent = Tag(name: \"ParkourLabs\");\nfinal tag1 = Tag(name: \"dust\", parent: parent);\n\nfinal tag2 = Tag(name: \"dynote\");\nparent.children$.insert(tag2);\n\nfinal toPrint = parent.children$.get(null).map((e) =&gt; e.name$.get(null)).join(',');\nprint(toPrint); // dust, dynote\nprint(tag1.parent$.get(null).name$.get(null)); // ParkourLabs\nprint(tag2.parent$.get(null).name$.get(null)); // ParkourLabs\nassert(identical(tag1.parent$, parent$)); // true\nassert(identical(tag2.parent$ == parent$)); // true\n</code></pre>"},{"location":"blog/2024/02/19/introducing-dust-v001/#state-management_1","title":"State Management","text":"<p>If you have noticed the \"ugly\" <code>.get(null)</code> API and have been wondering why we need to specify null in it. Here is the answer: you can optionally pass in an Observer instance to observe the changes in the field, or you could choose to use <code>.get(null)</code> to simply get the value inside without any reactivity.</p> <p>The rationale behind us making the Observer required but optional is that we want to remind you to explicitly think about whether you will need to subscribe to an observer. Oftentimes, we tend to forget such matters, and it would be difficult for us to realize or debug. While you may have to type more characters, we believe that this is a justifiable sacrifice. (We are implementing an optional flag where you can generate the convenient getters if you so choose).</p> <p>So here is how we implement a list of todos in dust:</p> <pre><code>class TodoList extends StatelessWidget {\n  const TodoList();\n\n  @override\n  Widget build(BuildContext context) {\n    // can choose a reactive widget\n    return ReactiveBuilder(\n       builder: (context, o) {\n         final list = const $TodoRepository().all().get(o);\n         return ListView.builder(\n           itemCount: list.length;\n           itemBuilder: (context, index) =&gt; TodoView(todo: list[index]),\n         );\n       },\n    );\n  }\n}\n\nclass TodoView extends ReactiveWidget {\n  const TodoView({required this.todo});\n\n  final Todo todo;\n\n  @override\n  Widget build(BuildContext context, Observer o) {\n    return ListTile(\n      title: Text(todo.name$.get(o)),\n      subtitle: Column(\n       children: [\n         Text(todo.description$.get(o) ?? 'No Description'),\n         const SizedBox(height: 8),\n         for (final tag in todo.tags$.get(o))\n           Chip(label: tag.name$.get(o)),\n       ],\n      ),\n      onTap: () {\n       if (todo.completed$.get(null)) {\n         todo.completed$.set(true);\n       } else {\n         todo.completed$.set(false);\n       }\n      }\n    );\n  }\n}\n</code></pre> <p>And you can implement a button to create a Todo anywhere -- it will be saved to the database and the ReactiveBuilder would be notified as well.</p> <pre><code>FilledButton(\n  onTap: () =&gt; Todo(name: 'Unnamed New Todo'),\n  child: Text('Create a new todo').\n);\n</code></pre> <p>The list of todos would be automatically updated. If you add a tag to the todo, the tags list of the todo would also be updated as well.</p>"},{"location":"blog/2024/02/19/introducing-dust-v001/#we-are-actually-pretty-bad","title":"We are actually pretty bad","text":"<p>Are you excited? Calm down.</p> <p>In writing this article, I find myself constantly getting hyped up by what we built. However, I worry that what I wrote would mislead you into thinking that we are doing what we did. I worry that my article would lead you into the same feeling when I read through the documentation of GetX, where I couldn't understand a lot of things, thinking that GetX was truly brilliant, and ended up realizing that they are overstating a lot of ungrounded claims.</p> <p>While I do think that dust is going to solve a lot of problems, it doesn't solve all.</p> <p>For example, because we are targeting local-first development, we built an AP (Available &amp; Partition-Tolerant, this is a concept in the CAP theorem) layer on top of sqlite. This essentially means that you cannot ensure certain guarantees on your data using dust. You would not be able to store the amount of coins that a user has in dust and guarantee that the user's balance is always above zero. You simply cannot do this because we guarantee that the user will always be able to write to the local database.</p> <p>To worsen the issue, dust is still at a very early stage. This means that a lot of things have not been implemented and a lot of problems have not been solved. This includes but is not limited to:</p> <ul> <li> <p>The APIs shown above have not been fully implemented yet. The majority of   the work has been done, and are getting there really really soon.</p> </li> <li> <p>The model names and the field names cannot be changed without losing access   to the data. We still need to implement a few annotations to get that right.</p> </li> <li> <p>We do not have any means of query filtering. You will have to query then   filter, or make use of the graph database capabilities by creating separate   entities and linking them together.</p> </li> <li> <p>The synchronization has not been implemented yet. We need to implement a few   network calls to get that right, but we haven\u2019t touched upon that part.</p> </li> <li> <p>The APIs are not yet stable, and we will have a lot of limitations.</p> </li> </ul>"},{"location":"blog/2024/02/19/introducing-dust-v001/#join-our-community","title":"Join our community","text":"<p>Are you still excited after seeing the previous section?</p> <p>Let\u2019s go!</p> <p>We would love to hear from you. Here is our telegram group link and github repository again:</p> <ul> <li>Telegram</li> <li>Github</li> </ul> <p>We are looking forward to talking to you!</p>"},{"location":"docs/docs/1.introduction/","title":"Introduction","text":"<p>Adapted from internal documentation by Bridgecat</p> <p>Welcome to <code>dust</code>. Please checkout the Quick Start Guide.</p> <p>As you would probably know by now, <code>dust</code> handles three things at once:</p> <ul> <li>State Management;</li> <li>Persistence;</li> <li>Synchronization (to be implemented).</li> </ul> <p>We want to do this so that when we build new apps, we don't need to define our models multiple times using multiple libraries while keeping everything 1-1 mapped. Our earlier experience with such attempts were horrible, and it significantly hindered our development of the file management page and the preferences page.</p> <p>Previously, we used:</p> <ul> <li>MobX, Riverpod, and   BLoC, combined with   Freezed for reactive states.</li> <li>Isar.</li> </ul> <p>The design of Qinhuai draws inspiration from MobX, Riverpod, Isar, as well as Freezed.</p>"},{"location":"docs/docs/1.introduction/#reactive-states","title":"Reactive States","text":"<p>Note that this portion is rather a big-picture view of the reactivity of dust. For simplicity of use, many classes introduced here would be automatically generated by <code>dust_generator</code>. Reading through this part here would not likely be very applicable unless encountered with more advanced usecases. However, it would hopefully make you understand more about how <code>dust</code> works as a state management solution.</p> <p>Ideally, when any value shown by a UI widget is changed, the widget should be rebuilt to reflect the latest state. In Qinhuai there are two closely-related interfaces: <code>Observable&lt;T&gt;</code> and <code>Observer</code>.</p>"},{"location":"docs/docs/1.introduction/#observablet","title":"<code>Observable&lt;T&gt;</code>","text":"<p><code>Observable&lt;T&gt;</code>: provides a <code>get(Observer? o)</code> function which retrieves its value and (optionally) registers an \"observer\" <code>o</code>.</p> <ul> <li>The \"observer\" will be \"notified\" when there is a possible change to the   underlying value.</li> <li>For clarity, prefer calling the aliases <code>watch(Observer o)</code> or <code>peek()</code>.</li> </ul> <p>Concrete classes can implement <code>Observable&lt;T&gt;</code>. Here are a list of common implementations:</p> <ul> <li><code>Active&lt;T&gt;</code>: the simplest obserable thing. Its value can be changed using the   <code>set(T value)</code> method. Data stored in <code>Active&lt;T&gt;</code> will be transient values,   and they will not be persisted to local storage. This is ideal for temporary   reactive values.</li> <li><code>Atom&lt;T&gt;</code>, <code>Link&lt;T&gt;</code>, <code>BackLinks&lt;T&gt;</code>: these are observables that store data   that can and will automatically be persisted to the disk and synchronized.</li> <li><code>Reactive&lt;T&gt;</code>: computes its value from other <code>Observable&lt;T&gt;</code>s and caches it.   When any of its dependencies is \"notified\", it will be \"notified\" as well.   The value would be recomputed lazily, ad the next invocation of <code>get</code>.</li> </ul>"},{"location":"docs/docs/1.introduction/#observer","title":"<code>Observer</code>","text":"<p><code>Observer</code>: provides a <code>visit(List&lt;VoidCallback&gt; posts)</code> function which allows it to be \"notified\".</p> <ul> <li>It can choose to execute side effects inside the <code>visit</code> function, or   (optionally) push \"post-visit callbacks\" into the <code>posts</code> list, having them   executed after the graph traversal completes.</li> <li>This <code>visit</code> is for implementation only. prefer calling <code>notify()</code>.</li> </ul> <p>Concrete classes can implement <code>Observer</code>:</p> <ul> <li><code>Trigger&lt;T&gt;</code>: watches an <code>Observable&lt;T&gt;</code> and triggers a callback each time it   is notified.</li> <li>Sometimes, the watched value may be notified without actually changing (e.g.   when something is assigned the same value multiple times). The variant   <code>Comparer&lt;T&gt;</code> would provide the previous value to the <code>callback</code>, allowing   filtering of such events.</li> </ul>"},{"location":"docs/docs/1.introduction/#widgets","title":"Widgets","text":"<p>There are two Flutter widgets that operate with the state management portion of <code>dust</code>:</p> <p><code>ReactiveWidget</code>: a widget that provides a \"observer\" <code>o</code> for use inside its <code>builder</code> parameter.</p> <ul> <li>The widget will be flagged for rebuild when the \"observer\" is \"notified\".</li> <li>Usage: inherit and override the <code>build</code> method.</li> </ul> <p><code>ReactiveBuilder</code>: a widget that provides a \"observer\" <code>o</code> for use inside its <code>builder</code> parameter.</p> <ul> <li>The widget will be flagged for rebuild when the \"observer\" is \"notified\".</li> <li>Usage: place it anywhere in a widget tree.</li> </ul>"},{"location":"docs/docs/1.introduction/#api-comparisons","title":"API Comparisons","text":"<p>The API of <code>dust</code> closely mimics that of <code>Riverpod</code>:</p> Data Node Widget Node Data B - Data A Widget B - Data A Update Data A Force Update Widget A <code>ChangeNotifier</code>(built-in) <code>ValueNotifier</code> (immutable)<code>ChangeNotifier</code>(mutable, manual) <code>AnimatedWidget</code> (base)<code>AnimatedBuilder</code> (builder) <code>A.addListener(() { /* Update B from A */ })</code> Include A in B's <code>listenable</code>/<code>animation</code> property (cannot be changed onece B is created) <code>A.value = value</code> (immutable)  <code>A.notifyListeners()</code> (mutable, manual) (no special way to force update widgets)"},{"location":"docs/docs/2.fields/","title":"Fields","text":"<p>TODO: write docs for fields</p>"},{"location":"docs/docs/3.links/","title":"Links","text":"<p>TODO: write docs for links</p>"},{"location":"docs/docs/4.annotations/","title":"Annotations","text":"<p>TODO: write docs for annotations</p>"},{"location":"docs/philosophy/1.think_in_a_graph_way/","title":"Think in a graph way","text":"<p>TODO: Write about how to model data using <code>dust</code></p>"},{"location":"docs/philosophy/2.state_management_theory/","title":"State Management Theory","text":"<p>TODO: migrate this document into the format renderable on katex.</p>"},{"location":"docs/philosophy/3.data_format/","title":"Data Format","text":"<p>TODO: migrate the internal doc inside Lark out to here describing the data format of <code>dust</code></p>"},{"location":"docs/philosophy/4.sync/","title":"Sync","text":"<p>SYNC HAS NOT BEEN IMPLEMENTED YET. THIS IS A TEMPORARY PLACEHOLDER DOCUMENT.</p>"},{"location":"docs/philosophy/5.dust_is_not_scalable/","title":"Dust is \"not scalable\"","text":"<p>If you come from \"traditional\" software world, you must think: hey! Dust is not scalable! By trying to merge the view-models into the models themselves, you are essentially trying to create more</p>"},{"location":"docs/qs/1-installation/","title":"Installation","text":"<p>Currently it's very involved to successfully install <code>dust</code>, as it would require you to have <code>cargo</code> installed with the required targets. You will also need to be familiar with using git-submodules for now, as we currently have not figured out how to ship dart packages with native code to <code>pub.dev</code>.</p>"},{"location":"docs/qs/1-installation/#step-1-install-cargo","title":"Step 1. Install Cargo","text":"<p>Follow the instructions on Cargo's website, and you should be good to go!</p>"},{"location":"docs/qs/1-installation/#step-2-add-targets","title":"Step 2. Add targets","text":"<pre><code># for targets relating to android\nrustup target add aarch64-linux-android armv7-linux-androideabi x86_64-linux-android i686-linux-android\n# for targets relating to macos\nrustup target add aarch64-apple-darwin x86_64-apple-darwin\n# for targets relating to ios\nrustup target add aarch64-apple-ios aarch64-apple-ios-sim x86_64-apple-ios\n# for targets relating to windows\nrustup target add x86_64-pc-windows-msvc\n# for targets relating to windows on arm\nrustup target add aarch64-pc-windows-msvc\n</code></pre>"},{"location":"docs/qs/1-installation/#step-3-add-submodules","title":"Step 3. Add submodules","text":"<p>Create a packages folder under your project root directory. We are going to pull down dust to a subfolder under the packages folder. You can also put dust under the root folder of your project. It's up to you.</p> <pre><code>\u251c\u2500\u2500 lib\n\u2514\u2500\u2500 packages/\n    \u2514\u2500\u2500 dust/ # we are going to put dust here!\n</code></pre> <p><code>cd</code> into the <code>packages</code> directory, and then run:</p> <pre><code>git submodule add https://github.com/Parkour-Labs/dust.git\n</code></pre> <p>Now the dust git repository will be added to your project as a git submodule. Note that you may face a lot of confusions if this is the first time that you are working with a git submodule. Here are a few tips:</p> <p>If you want to remove a submodule, do not delete directly. Instead, run:</p> <pre><code>git rm -rf YOUR_MODULE_PATH\n</code></pre> <p>When you want to clone down the repository on a new machine, run the following command:</p> <pre><code>git clone --recursive-submodules YOUR_REPOSITORY_GIT_URL\n</code></pre> <p>If you typed too quickly and forgot to do the recursive cloning, then run this git command:</p> <pre><code>git submodule update --init --recursive\n</code></pre> <p>Other than that, <code>git</code> submodules work very-much like a git repository.</p>"},{"location":"docs/qs/1-installation/#step-3-add-to-dust-to-pubspecyaml","title":"Step 3. Add to <code>dust</code> to <code>pubspec.yaml</code>","text":"<p>In your <code>pubspec.yaml</code>, add <code>dust</code> and <code>dust_generator</code> as follows:</p> <pre><code>dependencies:\n  # other dependencies\n  dust:\n    path: packages/dust/\n\ndev_dependencies:\n  # other dev dependencies\n  dust_generator:\n    path: packages/dust/generator/\n</code></pre>"},{"location":"docs/qs/1-installation/#step-4-add-other-optional-packages","title":"Step 4. Add other optional packages","text":"<p>Optionally, you may also want to add the following packages:</p> <ul> <li><code>flutter_hooks</code>, as we provide some hook apis and it can be handy to use;</li> <li><code>path</code>: utilities for dealing with path on various systems;</li> <li><code>path_provider</code>: utilities for reading some special paths for your   application. <code>dust</code> needs to know where to put its database file.</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}